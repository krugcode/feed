// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: jobs.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const CreateCrosspostJob = `-- name: CreateCrosspostJob :one
INSERT INTO crosspost_jobs (
    id, platform, post_id, created
) VALUES (
    ?, ?, ?, ?
) RETURNING id, platform, post_id, created
`

type CreateCrosspostJobParams struct {
	ID       string       `json:"id"`
	Platform string       `json:"platform"`
	PostID   string       `json:"post_id"`
	Created  sql.NullTime `json:"created"`
}

// Crosspost Jobs
func (q *Queries) CreateCrosspostJob(ctx context.Context, arg CreateCrosspostJobParams) (CrosspostJob, error) {
	row := q.db.QueryRowContext(ctx, CreateCrosspostJob,
		arg.ID,
		arg.Platform,
		arg.PostID,
		arg.Created,
	)
	var i CrosspostJob
	err := row.Scan(
		&i.ID,
		&i.Platform,
		&i.PostID,
		&i.Created,
	)
	return i, err
}

const CreateJob = `-- name: CreateJob :one
INSERT INTO jobs (
    id, job_name, status, result_message, completed, created
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING id, job_name, status, result_message, completed, created
`

type CreateJobParams struct {
	ID            string         `json:"id"`
	JobName       string         `json:"job_name"`
	Status        string         `json:"status"`
	ResultMessage sql.NullString `json:"result_message"`
	Completed     *time.Time     `json:"completed"`
	Created       sql.NullTime   `json:"created"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, CreateJob,
		arg.ID,
		arg.JobName,
		arg.Status,
		arg.ResultMessage,
		arg.Completed,
		arg.Created,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Status,
		&i.ResultMessage,
		&i.Completed,
		&i.Created,
	)
	return i, err
}

const GetCrosspostJobsByPlatform = `-- name: GetCrosspostJobsByPlatform :many
SELECT id, platform, post_id, created FROM crosspost_jobs 
WHERE platform = ?
ORDER BY created DESC 
LIMIT ? OFFSET ?
`

type GetCrosspostJobsByPlatformParams struct {
	Platform string `json:"platform"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) GetCrosspostJobsByPlatform(ctx context.Context, arg GetCrosspostJobsByPlatformParams) ([]CrosspostJob, error) {
	rows, err := q.db.QueryContext(ctx, GetCrosspostJobsByPlatform, arg.Platform, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CrosspostJob{}
	for rows.Next() {
		var i CrosspostJob
		if err := rows.Scan(
			&i.ID,
			&i.Platform,
			&i.PostID,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCrosspostJobsByPost = `-- name: GetCrosspostJobsByPost :many
SELECT id, platform, post_id, created FROM crosspost_jobs 
WHERE post_id = ?
ORDER BY created DESC
`

func (q *Queries) GetCrosspostJobsByPost(ctx context.Context, postID string) ([]CrosspostJob, error) {
	rows, err := q.db.QueryContext(ctx, GetCrosspostJobsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CrosspostJob{}
	for rows.Next() {
		var i CrosspostJob
		if err := rows.Scan(
			&i.ID,
			&i.Platform,
			&i.PostID,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetJob = `-- name: GetJob :one
SELECT id, job_name, status, result_message, completed, created FROM jobs WHERE id = ?
`

func (q *Queries) GetJob(ctx context.Context, id string) (Job, error) {
	row := q.db.QueryRowContext(ctx, GetJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Status,
		&i.ResultMessage,
		&i.Completed,
		&i.Created,
	)
	return i, err
}

const GetJobsByName = `-- name: GetJobsByName :many
SELECT id, job_name, status, result_message, completed, created FROM jobs 
WHERE job_name = ?
ORDER BY created DESC 
LIMIT ?
`

type GetJobsByNameParams struct {
	JobName string `json:"job_name"`
	Limit   int64  `json:"limit"`
}

func (q *Queries) GetJobsByName(ctx context.Context, arg GetJobsByNameParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, GetJobsByName, arg.JobName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Status,
			&i.ResultMessage,
			&i.Completed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobs = `-- name: ListJobs :many
SELECT id, job_name, status, result_message, completed, created FROM jobs 
ORDER BY created DESC 
LIMIT ? OFFSET ?
`

type ListJobsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Status,
			&i.ResultMessage,
			&i.Completed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobsByStatus = `-- name: ListJobsByStatus :many
SELECT id, job_name, status, result_message, completed, created FROM jobs 
WHERE status = ?
ORDER BY created DESC 
LIMIT ? OFFSET ?
`

type ListJobsByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListJobsByStatus(ctx context.Context, arg ListJobsByStatusParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, ListJobsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Status,
			&i.ResultMessage,
			&i.Completed,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs 
SET 
    status = ?,
    result_message = COALESCE(?, result_message),
    completed = COALESCE(?, completed)
WHERE id = ?
RETURNING id, job_name, status, result_message, completed, created
`

type UpdateJobStatusParams struct {
	Status        string         `json:"status"`
	ResultMessage sql.NullString `json:"result_message"`
	Completed     *time.Time     `json:"completed"`
	ID            string         `json:"id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, UpdateJobStatus,
		arg.Status,
		arg.ResultMessage,
		arg.Completed,
		arg.ID,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Status,
		&i.ResultMessage,
		&i.Completed,
		&i.Created,
	)
	return i, err
}
